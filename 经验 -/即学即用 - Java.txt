常用手法	-	
	由核心类向它依赖的接口和类展开去写
	new IService(){ pulic void get(){}};
	组合
	多态
	重载
	封装整合功能
	泛型 public <T> T create(Class<T> clazz); class Factory<K,V>{} 	 public static <X> List<X> join(X[]... elements) {}
	继承 public abstract class Job{ public abstract void run(){}; public void log(){this.run();}}
		   public class MyJob extends Job{public void run(){};}
	单例模式
	工厂模式
	桥接模式
	异步回调
	分而治之
	我依赖你某个接口，然后再内部的方法内，执行这个接口的方法完成事件，你只需要在调用我的时候传入这个接口实现类
	
	for{}
	while{}
	if{}
	switch{}
	
	enum
	interface
	abstract class
	
	Object... arguments
	HessianConnection connection = super.open(url);
	task.setSearchService(this);
	private boolean isRunning = false;
	
	public void handleRequest(){validate(); super.handleRequest();}
	this(param1, param2);
	
	
常用api	-	
	String
	List
	Map
	Array
	Set
	Xml
	Json
	以上类型复杂组合
	Thread
	Runnable
	FileUtils
	注解
	private static ThreadLocal<MessageDigest> MD = new ThreadLocal<MessageDigest>();// 所谓ThreadLocal，简单一点想，就是一个全局的Map，Map的key是线程对象，value是你要保存的对象， 进入某个线程后，就可以从map中取得之前存储的相应线程关联的对象
	
	charAt()
	AtomicLong
	Charset
	Arrays
	java.io.InputStream
	java.io.OutputStream
	java.io.BufferedReader
	java.util.concurrent.ThreadFactory
	java.lang.SecurityManager
	java.lang.System
	ServerSocket
	java.net.URL
	java.io.File
	java.io.StringWriter
	java.util.Collections
	org.w3c.dom.Document
	
	
		
常用api	-	先记住有些什么功能，用的时候再详细查看
	package:
		java awt - 图形界面
	
进制转换：
	16进制0x： 0-10-a-f, a相当于10进制的10，f相当于十进制的15
	8进制o：  0-8
	2进制：  0-1
	10进制： 0-10
	
	16进制转10进制：1f = 1*16+15 = 31
	
	
transient - 短暂的，不会被序列化持久化到磁盘里，防止敏感信息泄露
java -jar test.jar	-	
ClassLoader	-	程序在启动的时候，并不会一次性加载程序所要用的所有class文件，而是根据程序的需要，通过Java的类加载机制（ClassLoader）来动态加载某个class文件到内存当中的，从而只有class文件被载入到了内存之后，才能被其它class所引用。所以ClassLoader就是用来动态加载class文件到内存当中用的。

