常用手法	-	
	嵌套
	管道命令
	$(命令)

常用命令	-	
	--help -	命令帮助 mkdir --help
	ssh root@xx.xx.xx.xx
	cd /xxx
	ls/ll	-	ls -t #按时间排序， ls -aF --color=always #列出所有文件包括隐藏文件，并附加指示符和颜色标识, ls -l， ls -lh #符合人类阅读习惯的格式， ls -F #结果中带有/表示目录，无特殊字符表普通文件，@表示链接文件，*表可执行文件， ls -R #递归列出子目录
	rm
	mv
	vim xxx.log
	top
	chmod 775 xxx.log
	chown
	sudo chown -R svnadm:users mysql/
	scp svnadm@10.12.153.163:/data/home/carlcyang/ ./
	rsync -avz  svnadm@10.6.19.149:/usr/local/mysql/ /usr/local/mysql
	uptime
	
	env/printenv	-	查看当前shell所有系统变量
	echo
	export	- export JAVA_HOME=/usr/local/java	将变量指定给后续的命令执行环境(如子shell)
	bash	-	创建一个子Shell
	exit	-	0成功，其他值失败
	echo $$	-	后台运行的最后一个进程的进程ID号
	
	bash test.sh	-	执行test.sh脚本
	./test.sh	-	执行test.sh脚本
	sh test.sh	-	执行test.sh脚本
	history	-	显示历史命令ctrl+r搜索，方向键上下切换
	!!	-	重复执行上一条命令
	!up/10	-	回调历史命令以up开头的命令，或者历史命令id为10的命令
	
	upset	-	upset JAVA_HOME 删除变量
	
	$(uptime)/`uptime`	-	命令替换：用命令的输出替换命令本身，是执行里面的代码得到的结果，
	${}	-	是参数，{}是为了避免后面的影响到了，比如参数${a}a这样连着使用。如果不用{}，系统就会识别成$aa了
	$	-	$var：获取var变量的值
	$$ 脚本运行的当前进程ID号
	$1～$n 添加到Shell的各参数值。$1是第1参数、$2是第2参数...
	{}	- 从左至右扩展	echo a{b,c,d}e 输出： abe, ace, ade ; echo {a..z} 输出：a~z ; echo {0..10} 输出:0~10 ; echo {0,1}{a,b} 输出:0a 0b 1a 1b ; echo {a,b{1..3},c} 输出：a b1 b2 b3 c
	| -	管道命令
	~	-	Home目录
	~carlcyang	-	carlcyang的Home目录
	mkdir	-	创建目录: mkdir ~/{dir1,dir2,dir3} #在home下创建dir1,dir2,dir3三个目录
	\	-	转义	\n
	sudo	-	授权执行命令
	
	pwd	-	显示当前所在目录
	*/?/[...]	-	文件名扩展 通配符 	ls /etc/*.conf #显示所有已.conf结尾的文件; ls image?.jpg #显示image1.jpg,image2.jpg; ls/etc/[ab]*.conf #显示a.conf,b.conf
	
	
	alias	-	创建别名		alias test='ls -l'; test		alias ..='cd ..'	
	unlias	-	删除别名		unalias test	unalias -a #删除所有别名
	head	-	ls -t | head -2 #当前目录按时间排序取前2个文件
	find	-	find . -type f - exec ls -s {} \; | sort -n -r | head -5 #找出当前目录下, 5个最大的文件
	
	.	-	当前路径
	..	-	上一级路径
	../../	-	上上一级路径
	
	
	df -h -	磁盘空间使用情况， -h单位格式化输出
	du - d 1 -h /home/carlcyang	-	#查看目录所占用空间	-d递归深度 -h 文件大小单位输出
	
	dump	-	判断是否死锁及线程阻塞原因	/usr/local/jdk/bin/jmap -dump:format=b,file=./heamdump.out 25520
	touch	-	创建新的空文件或者修改已有文件的时间戳
	cat -n xxx.log - -n显示行号， cat > test #输入内容到test， cat test test2 > test3 #将test test2文件内容重定向test3
	more	-	从前向后分页展示文件内容，按Enter:下一行，空格键：下一页，F：显示下一屏内容，B：显示上一屏内容
	less	-	从后向前展示文件内容，支持内容查找，高亮显示
	tail -f -n100 xx.log	-	文件最后100行，-f:让tail程序不退出，并持续显示新增的行
	head -n2 xx.log	-	显示文件开头的一组行
	sort -n xx.log	-	文件内容排序 -r:按逆序排， -k 2:指定按第二列排序， -t ' ': 指定列的分隔符为空格
	wc	-	统计字符数，字数，行数
	uniq xx.log -c	-	查看重复出现的行 -c:查看重复行次数， sort xx.log | uniq -c #先排序后显示重复行
	grep qq xx.log	-	查找符合条件的字符串 -c: 匹配的总行数
	find /home -name xx.log -	在home目录下查找文件名xx.log路径 -delete: 查找后删除 find /home -name "*.log" #查找.log结尾的文件 find . -print #递归打印所有文件
	whereis	zkCli.sh - 定位可执行文件的位置
	expr 10 / 10	-	对运算表达式或者字符串进行运算求值 expr length "good" #计算字符串good长度
	tar	-	归档文件	tar -cf a.tar detach tmp #将detach和tmp目录打包成a.tar -t: 列出包中文件的名称 -x：解压 -f：包的名称 -c：生成新的包 tar -xvf a.tar
	tar --help > test.txt	- #将tar --help执行结果输出的test.txt文件中（完全覆盖）
	tar --help >> test.txt	- #将tar --help执行结果输出的test.txt文件中（在末尾追加内容）
	tar -tf a.tar 等同于 tar -t -f a.tar
	
	curl -i www.baidu.com -	#抓取网页内容， 完成提交表单 -i：返回带http header的信息
	wget www.baidu.com	-	#下载网页信息
	
	cut -f1 -d " " xx.log	- #截取每一行的特定部分并送到标准输出， （例中将xx.log每行按空格拆分取第一列数据）
	sed	-	#流编辑器，按行处理，【不会修改文件本身】	sed 's/good/bad/' access.log | head -10 #替换日志中的good为bad 	sed -n '2,6p' access.log #-n:只输出指定的行，2,6p：选择第二到第六之间的行	sed '/qq/d' access.log #根据正则删除日志中的指定行，删除有qq字符的行	sed '=' access.log #显示文件行号 sed -e 'i\head' access.log | head -10 #在每行首插入head字符串	sed -e 'a\end' access.log | head -10 #在每行末插入end字符串
			sed -n -f cmdfile access.log #可以将sed命令放到文件中执行, cmdfile文件内容： s/good/bad/ #good替换成bad
																					   1,6p #打印第1到6行
																					   1,6= #打印第1到6行行号
			【sed不能处理类似编译环境的文本处理规则，可以用awk】
	awk	-	提供类似编程的开放环境，可以自定义文本处理规则，【提供一种编程语言而不仅仅是一组文本编辑的命令，可使用if和循环语句】
			awk [option] 'pattern {action}' file #option为命令选项，pattern为行匹配规则，action为执行的具体操作，如果没有pattern，则对所有行执行action，如果没有action，则打印所有匹配的行，file为输入的文件
			awk '{print $1}' access.log | head -10 #打印文件指定的列 print:格式化输出，$1：第一列，awk默认用空格将一行分割为多个列，-F：指定分隔符
			awk '/google/{print $5,$6}' access.log #查找包含google字符串的行，打印第5，6列
			awk 'length($0)>40{print $3}' access.log #查找大于40的行，打印第3列, $0：行本身，$3：第3列
			awk '{line = sprintf("method:%s,response:%s", $3, $7); print line}' access.log | head -10 #格式化输出：method:GET,response:12111
			awk -f testawk access.log #将awk命令和程序写在testawk文件中
			
	top	-	系统负载，按1查看每核cpu利用率，us: 用户进程占用时间，sy: System time 内核态所花费的时间，频繁的用户态与内核态切换, ni: nice time系统调整进程优先级耗时 id:idle time, wa: waiting time表示cpu在等待i/o操作所花费的时间， hi: hard irq time系统处理硬件中断所占用的时间， si: soft irq time 系统处理软件中断所占用时间 st: steal time丢失时间,当前虚拟机和宿主的其他虚拟机cpu争用频繁
	top -p 2102	-	按进程来查看cpu利用率
	uptime	-	load average: 0.22(1分钟内的load值),0.36(5分钟内),0.26(15分钟内) load值小于3，系统负载正常，load值大于5，系统负载很高
	jps	-	java应用线程
	sprintf	-	格式化输出，awk '{line = sprintf("method:%s,response:%s", $3, $7); print line}' access.log | head -10 #格式化输出：method:GET,response:12111
	ntpdate -u 210.72.145.44	-	网络时间同步命令
	file	-	查看文件类型
	
	
	sar -n DEV 1 1	-	查看网络状况
	iostat -d -k	-	磁盘I/O
	free -m	-	内存使用
	vmstat	-	swap i/o的情况
	
	qps	-	query per second
	rt	-	response time
	select/ps, update/ps, delete/ps	- 数据库每秒查询，更新，删除请求数量
	gc	-	java gc发生时，jvm上的应用程序的工作线程将会暂时停止运行，会导致卡顿情况，频繁的Full gc是有性能问题的
	
	ping	-	心跳检测 -c次数
	
	set -o	-	bash内置命令， set -o allexport #开启allexport命令 set +o allexport #关闭allexport命令
	shopt -s	-	bash内置命令， shopt -s feature-name #开启feature-name命令， shopt -u feature-name #关闭命令
	
	
	
常用组合命令	-	
		cat access.log | cut -f1 -d " " | sort | uniq -c | sort -k 1 -n -r | head -10	-	#访问量排名前十的IP地址，访问前十页面地址，最耗时间
		export total_line=`wc -l access.log | cut -f1 -d " "` && export not_found_line=`awk '$6='404'{print $6}' access.log | wc -l` && $not_found_line \* 100 / $total_line	-	#统计404请求码占比
		sed -n '1,5p;1,5=' access.log #这是两条命令，第一个是打印出第一行到第五行，第二条命令式将第一行到第五行每一行的行号打印出来
常用脚本	-	
	stop.sh	-
		#!/bin/sh

		pidlist=`ps -ef | grep /usr/local/gearman/sbin/gearmand | grep -v "grep" | awk '{print $2}'`
		echo "pidlist: $pidlist"
		if [ "$pidlist" == "" ]
		then
			echo "no pidlist"
		else
			for pid in ${pidlist}
			{
				kill -9 $pid
				echo "kill pid: $pid"
			}
		fi


	监控每个应用业务列表	-	
		#！/bin/bash
		export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib
		CURL=/usr/local/bin/curl
		URL_FILE=/home/carlcyang/checklist
		HOST="http://192.1.1.1:8080"
		OUTPUT=""
		STATUS=1 #1:success 2:error
		
		while read LINE
		do
		 result=`$CURL -s -I ${HOST}${LINE} | grep 'Server-Status' | awk -F : '{print $2}'`
		 if [[ $result = *ok* ]];then
			continue
		 else
			STATUS=2
			OUTPUT="$OUTPUT $LINE"
		 fi
		done < $URL_FILE
		
		if [ $$STATUS -eq 1 ];then
			echo "success"
		else
			echo "$OUTPUT error"
		fi

		exit 0
		
	查看系统load超过2和磁盘利用率超过85%告警	-	
		#!/bin/bash
		load=`top -n 1 | sed -n '1p' | awk '{print $11}'`
		load=${load%\, *}
		disk_usage=`df -h | sed -n '2p' | awk '{print $(NF - 1)}'`
		disk_usage=${disk_usage%\%*}
		overhead=`expr $load \> 2.00`
		if [ $overhead -eq 1 ];then
			echo "system load is overhead"
		fi

		if [ $disk_usage -gt 85 ];then
			echo "disk is nearly full, need more disk space"
		fi
		exit 0
		
	将操作日志入mysql数据库	-	
		#!/bin/bash
		ACCESS_FILE=/home/access.log
		MYSQL=/usr/bin/mysql
		while read LINE
		do
			OLD_FILS="$IFS"
			IFS=" "
			field_arr=($LINE) #空格拆分为数组
			IFS="$OLD_IFS"
			STATEMENT="insert into access_log values('${field_arr[0]}','${field_arr[1]}');"
			echo $STATEMENT
			
			$MYSQL test -u root -p123456 -e "${STATEMENT}"
		done < $ACCESS_FILE
		exit 0
		
		
	
常用快捷键	-	
	ctrl+w： 删除光标位置前的单词
	ctrl+u： 清空行
	tab： 自动补全
	ctrl+r： 搜索先前使用的命令
	ctrl+c： 终止当前命令
	ctrl+d： 退出登录shell
	esc+t： 调换光标前的两个单词
	ctrl+e： 光标置尾
	ctrl+a： 光标置首
	GG: 光标移至编辑文件的末尾
	
	vim文件后，输入/test搜索test字符串，n：next, N：pre，?test向回搜索test字符串
	
表达式	-	
	[[ $a == z* ]]    # 如果$a以"z"开头(模式匹配)那么结果将为真
	[[ $a == "z*" ]]  # 如果$a与z*相等(就是字面意思完全一样), 那么结果为真.
		  
	[ $a == z* ]      # 文件扩展匹配(file globbing)和单词分割有效.
	[ "$a" == "z*" ]  # 如果$a与z*相等(就是字面意思完全一样), 那么结果为真. 
	
	
	file=/dir1/dir2/dir3/my.file.txt
	${file#*/}：拿掉第一条 / 及其左边的字符串：dir1/dir2/dir3/my.file.txt
	
	+ - * / ：分别为 "加、减、乘、除"。
	% ：余数运算
	& | ^ !：分别为 "AND、OR、XOR、NOT" 运算。
	
	<：小于
	>：大于
	<=：小于或等于
	>=：大于或等于
	==：等于
	!=：不等于

文件和目录	-	
	-rw-r-----：-：普通文件,如果为d表目录，s表套接文件，l表链接文件， rw-：所有者有读写权限，r--：用户组有读权限，---：其他用户没有任何权限
	-rw-r----- 1 root root： 字段2：有1个链接到此文件，字段3：所有者，字段4：用户组
Shell	- 用户和Linux内核进行交互的接口
	查看正使用的shell类型： 1. grep root /etc/passwd 
							  root:x:0:0:root:/root:/bin/bash
						   2. echo $SHELL 
						   3. ps -p $$
						  
	cat /etc/shells
	/bin/bash
	/bin/sh
	/bin/dash
	/bin/rbash
	
	awk
	sed
	grep
	cut
	函数: /etc/init.d/functions
	if...else, for do...done
	export echo exit pwd return
	date rm mkdir
	
	
	用途：
		自动化工具， 
		监控你的Linux系统，
		备份数据和创建快照，
		创建邮件告警系统，
		查找耗尽系统资源的进程，
		查找是否所有的网络服务运行正常
		
	例子:
		--------------------------------------
		#!/bin/bash
		#my first shell
		ls -l .*
		--------------------------------------
		chmod 775 my_shell
		./my_shell
		
Linux -	内核，Shell，终端模拟器(输入命令及回显结果)，桌面和窗口管理器
		
主流Linux	-	
	Ubuntu, Linux Mint, Red Hat, Fedora, CentOS, openSUSE(有商业版), Arch Linux

Linux Kernel(内核)	-	
	进程管理 定时器 中断管理 内存管理 模块管理 虚拟文件系统接口 文件系统 设备驱动程序 进程间通信 网络管理 系统引导

Linux理念	-	
	小即是美
	让程序只做好一件事
	可移植性比效率更重要
	一切即文件： 使用方便而且把硬件作为文件处理是安全的
	使用Shell脚本来提高效率和可移植性
	避免使用可定制性低下的用户界面
	所有程序都是数据的过滤器
	
	
	

		
sleep 2	-
	
sed	-	#流编辑器，按行处理，不会修改文件本省	
	sed 's/good/bad/' access.log | head -10 #替换日志中的good为bad 	
	sed -n '2,6p' access.log #-n:只输出指定的行，2,6p：选择第二到第六之间的行	
	sed '/qq/d' access.log #根据正则删除日志中的指定行，删除有qq字符的行
	sed '=' access.log #显示文件行号
	sed -e 'i\head' access.log | head -10 #在每行首插入head字符串
	sed -e 'a\end' access.log | head -10 #在每行末插入end字符串
	sed -n -f cmdfile access.log #可以将sed命令放到文件中执行, cmdfile文件内容： s/good/bad/ #good替换成bad
																			   1,6p #打印第1到6行
																			   1,6= #打印第1到6行行号
ubunton	-	
	桌面切换到命令窗口: ctrl+alt+F2
	命令窗口切换到桌面: ctrl+alt+F7

sudo 授权管理员权限 	-	

whereis nginx - 

scp	-	远程同步
	scp svnadm@10.12.121.121:/data/home/carlcyang ./

rsync	-	远程同步
	rsync -avz  svnadm@10.6.19.149:/usr/local/mysql/ /usr/local/mysql

ls	-	
	ls | xargs -i du -hs {}

wget	-	从网络上下载文件
	wget http://baidu.com
	
curl	-	查看或下载网页信息
	curl -u username:password https://testsite/test.html
	-x: -x 123.45.67.89:1080	代理
	-o: -o test.html	下载到本地
	-O: -O 下载到本地，有默认文件名
	正则: curl -O  https://testsite/[100-200].html 下载100.html到200.html文件
	
变量	-	系统变量(环境变量)和自定义变量(本地变量或Shell变量)
	系统变量： BASH_VERSION, DISPLAY, EDITOR, HISTFILE, HISTFILESIZE, HISTSIZE, HOME, HOSTNAME, IFS, PATH, PSL, PWD, SHELL, TERM, TMOUT
	变量定义： username="carlcyang" 或 username=carlcyang 或 username=$(carlcyang) 或 let sum=2+1  let sum=$sum+1
			  echo -n "enter you name:"; read username; echo $username
			  export JAVA_HOME=/usr/local/java	将变量指定给后续的命令执行环境(如子shell)
	变量打印：echo $username 或 printf $username
	变量引用：echo $username 或 echo "$username"	 区别如：username=carlcyang lily;  COMMAND $username #COMMAND带有两个参数; COMMAND "$username"带有一个参数
	变量删除：unset username
	变量是否存在：echo ${username?Error: not defined.} 或 echo ${username:?Error: not defined.} 区别： :?表示如果username等于空也抛出Error: not defined.
	
	
内置变量	-	
	$# 传递到脚本的参数个数
	$* 以一个单字符串显示所有向脚本传递的参数，与位置变量不同，此选项参数可超过9个
	$$ 脚本运行的当前进程ID号
	$! 后台运行的最后一个进程的进程ID号
	$@ 与$#相同，但是使用时加引号，并在引号中返回每个参数
	$- 显示shell使用的当前选项，与set命令功能相同
	$? 显示最后命令的退出状态。0表示没有错误，其它任何值表明有错误
	$0 Shell本身的文件名
	$1～$n 添加到Shell的各参数值。$1是第1参数、$2是第2参数...
	
for -	
	LIST="one two three"
	for var in $LIST #将变量LIST的值分为了3个参数传给了for循环
	for var in "$LIST" #将变量LIST的值作为一个整体传入for循环
	do	
		echo "$var"
	done
	
echo printf区别	-	printf可以格式化打印 printf "%s\n" "carlcyang"

回调命令历史	-	Bash将历史命令保存在缓冲区或默认文件~/.bash_history
	history	-	显示历史命令ctrl+r搜索，方向键上下切换
	!!	-	重复执行上一条命令
	!up/10	-	回调历史命令以up开头的命令，或者历史命令id为10的命令
	
文件说明	-	
		/etc/profile	-	用户在运行级别3登录是系统时首先运行
		/etc/profile.d	-	在/etc/profile运行时，调用该目录下的一些脚本
		$HOME/.bash_profile, $HOME/.bash_login, $HOME/.profile -	在/etc/profile运行后，第一个存在的被运行
		$HOME/.bashrc	-	上述脚本中的一个运行后即调用此脚本
		/etc/bashrc 或 /etc/bash.bashrc	-	由$HOME/.bashrc调用运行
扩展{}	-	
	echo a{b,c,d}e 输出： abe, ace, ade
	echo {a..z} 输出：a~z
	echo {0..10} 输出:0~10
	echo {0,1}{a,b} 输出:0a 0b 1a 1b
	echo {a,b{1..3},c} 输出：a b1 b2 b3 c
	echo {<START>..<END>..<INCR>} echo {1..10..2} 输出：1 3 5 7 9 ; echo {10..1..-2} 输出：10 8 6 4 2; echo {a..h..3} 输出：a d g
	echo {0001..10..3} 输出：0001 004 007 0010; 不足4位前面补零

文件名扩展 通配符	-	
		* - 匹配任何字符串，包括空字符串	ls /etc/*.conf
		? - 匹配任意单个字符串	ls image?.jpg #显示image1.jpg,image2.jpg
		[...] - 匹配方括号内的任意字符	ls/etc/[ab]*.conf #显示a.conf,b.conf
	
波浪号~	-	
	echo ~ 当前用户的Home目录
	echo ~carlcyang carclyang的Home目录
	echo ~+ 等同于 echo $PWD
	echo ~- 等同于 echo $OLDPWD


	

	